#### 20191223

## 1.sublime text插件安装(亲测不好用,记录一下)

1. 安装

    sudo apt-get install sublime-text

不能安装的话添加一下软件源再输入上一条命令安装

    sudo add-apt-repository ppa:webupd8team/sublime-text-3    
    sudo apt-get update 

2. Sublime Text 3配置及插件

安装好Package Control就可以安装插件了，Sublime最强大的它丰富的插件
Ctrl+Shift+P找到Package Control: Install Package（输入pki就能找到），按Enter确定可能会有点慢，可以看到下面状态栏左边有个’=’在左右移动就说明在就加载中
加载出来就可以搜索安装插件了

有下面这些有用的插件可以安装

BracketHighlighter 引号高亮匹配
C++ Snippets C++代码补全
ChineseLocalization 汉化
MarkDown Editing 看名字就知道是干嘛的了
MarkDown Preview 看名字就知道是干嘛的了
MarkDown TOC 加入目录，有的Markdown不支持[TOC]语法的就可以用这个
上面两个软件要Sublime自带的markdown系统，设置-ignored-packages里面加一个Markdown（系统自带Markdown）


    "ignored_packages":
    [
        "Markdown",
    ],

但我觉得这个并不好用，直接用stackedit.io/editor这个网页版的Markdown编辑器就好了，功能强大，虽然是个网页，但可以离线打开，可以云盘同步自动保存到云盘，直接可以Publish到博客（但只支持一些国外的博客），保存成pdf虽然要收费但是可以点开StackEdit Viewer然后用Chrome打印功能存成PDF，排版完美，感觉是良心开发者故意留的

ConvertToUTF8 编码转换

SublimeLinter
静态代码校验，超强大，能检查数组越界等编译不能检查出来的bug
    安装sublimeLinter 和 SublimeLinter-cppcheck
    安装cppcheck(sudo apt-get cppcheck，自己下载的安装包倒腾了好久都没弄好，编译安装好了后运行一直缺少文件，最后发现可以直接apt-get，md，可以apt-get你给我个包让我自己编译安装？？？）
    打开SublimeLinter的linter和linting（Ctrl+Shift+P找到这两个选项）
    在tools/SublimeLinter里设置Linter Mode为load&save（在载入和保存代码的时候检查）， Mark Style设置成自己喜欢的

SublimeAStyleFormatter 代码格式化，一键整理代码，主要是括号，空格和缩进等的格式化，能力有限，但一些特殊情况下还是能派上大用场的，Ctrl+Alt+F格式化

3. Sublime Text 3配置C/C++开发环境

虽然直接Ctrl-B就能编译，但Sublime内置的编译系统并不好用
可以自己在编译系统里面新建一个自己的编译系统
点开新建编译系统，将这一段复制进去，保存为My_C++

    {
    "cmd" : ["g++", "-std=c++14", "$file_name", "-o", "${file_base_name}", "-lm", "-Wall"],
    "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$",
    "selector" : "source.c, source.c++",
    "shell":false,
    "working_dir" : "$file_path",
    
    "variants":
    [
        {
            "name": "My_Run",
            "cmd": ["gnome-terminal", "-e", "bash -c \"'${file_path}/${file_base_name}' ; read -p '\nPress any key to continue...'\""]
        }
    ]
    }

这样就多出了一个My_C++的编译选项了，My_C++是编译，My_C++ Run是打开终端并运行编译好的程序
添加快捷键
打开首选项的快捷键设置，加入

    [
        { "keys": ["f8"], "command": "build" },
        { "keys": ["f9"], "command": "build", "args": {"variant": "My_Run"} },
    ]

F8编译，F9运行，原来Sublime F9是一键排序代码，就是把每一行按字典序重排，并没有什么用，覆盖掉算了
4. Sublime Text 3中文输入问题解决

Ubuntu下Sublime不能输入中文，很简单就能解决的事情，不知道为什么开发者一直不解决

    //下载一个东西
    git clone https://github.com/lyfeyaj/sublime-text-imfix.git
    //复制文件
    cd ~/sublime-text-imfix
    sudo cp ./lib/libsublime-imfix.so /opt/sublime_text/
    sudo cp ./src/subl /usr/bin/

终端输入subl进入Sublime就可以输入中文，用其他方法进入Sublime不能输入中文，要解决这个问题看下面的参见，不过我觉的这样就好了，我都是写了几天的代码才发现不能输入中文这件事的

    参见解决Ubuntu下Sublime Text 3无法输入中文

插件、配置备份

把这个目录下全部打包备份，下次安装覆盖就好了

    ~/.config/sublime-text-3/Packages/

如果要跨平台的话, 只需要备份Packages/User里面的文件就好了, 覆盖之后会自动重新安装插件和恢复配置, 但跨平台的话还是有些东西不能兼容要自己改, 比如自己新建的编译系统里的编译运行的命令

## 2. ros ide

http://wiki.ros.org/IDEs

#### General

On ROS Answers there is a thread about [Which IDE(s) do ROS developers use?](http://answers.ros.org/question/9068/which-ides-do-ros-developers-use) that might have further hints not yet entered here. 

##### Reusing your shell's environment

For building and running ROS programs from inside IDEs, the ROS enviroment has to be set up. All IDEs might have a config for that and, **for most IDEs, the easiest way is to run it from a ROS-sources shell**. Differently, **CLion has a plugin allowing to automatically setup it, avoid the trouble** to run CLion from a ROS-sourced shell. 

Likewise, you can enhance your IDE's launcher icon to load your shells environment. E.g., replace its command *`eclipse`* with *`bash -i -c "eclipse"`*. This will make bash source `~/.bashrc`, in which ROS has to be sourced and parameterized, and start that IDE .  For convenience, you can also launch it by default like this by changing the *`Exec=`* line in your *`eclipse.desktop`* launcher (which you need to create manually if you install Eclipse from the Eclipse website directly). 

#### Anaconda

When Anaconda installs, it will create a path in your .bashrc file. (press ctrl + h in home directory to view file) 

example:  

```
####### added by Anaconda x.x.x installer
export PATH="/home/"user"/"anaconda version"/bin:$PATH"
```



Having an active Anaconda path in your .bashrc will cause errors when you try to use ROS. 

The solution to the problem is to comment out the path: 

```
#export PATH="/home/"user"/"anaconda version"/bin:$PATH"
```



In order to use Anaconda, simply paste in the Anaconda path when you start a new terminal; and hit enter. Then use as normal. This will allow you  to use ROS and Anaconda on the same system. 



#### Eclipse



Eclipse's built in C++ indexing capabilities have gotten quite good in recent versions. 



##### Installing Eclipse



To use this tutorial, users should not "sudo apt-get install eclipse". Instead: 

- Go to [eclipse web site](http://www.eclipse.org) 
- Click on "download now" from the top-right corner 
- Download eclipse for C/C++ developers 
- Extract eclipse into a folder of your choice 
- To make a nice launcher for Ubuntu, google for instructions or check e.g. http://www.blogs.digitalworlds.net/softwarenotes/?p=54 



##### Creating the Eclipse project files





###### For a rosbuild package



CMake can  produce Eclipse project files automatically. These project files then  set up all include paths correctly, so that auto completion and code  browsing will work out of the box. 

However, currently, a small hack is required for generating these project files  in the right folder. The problem is that ROS creates the Makefiles and  all other build artifacts in the **build/** folder, but Eclipse expects the source files to be located within (or below) the folder where its project files are stored. 

Fortunately, there is now a make target using a small script that circumvents this  problem, by forcing CMake to create the project files in the directory  of your package (and not the **build/** folder). Proceed as follows: 

Open a terminal, **roscd** into the folder of your package, and execute: 

```
make eclipse-project
```



You will now find two Eclipse files in your package. It is not recommended  to add them to the repository, as they contain absolute links and will  be different for different users checking out your software. 

Note that if you change anything to your **manifest.xml**, you will have to run this script again, which will overwrite your  Eclipse project file and thereby reverting all manual changes to the  project settings. 

**Note**: Simply running the cmake Eclipse generator like 

```
cmake -G"Eclipse CDT4 - Unix Makefiles"
```



will overwrite the Makefile. This can also happen if `make eclipse-project` does not complete successfully. If you already did this, you will want  to restore the original Makefile, which should contain the following  line: 



```
include $(shell rospack find mk)/cmake.mk
```





####### Creating eclipse files for multiple packages/stacks



Go to the directory where your packages reside (which may be a stack-folder or just a simple folder) and run: 

```
rosmake --target=eclipse-project --specified-only *
```



If you need to convert deeper nested packages or multiple stacks at once be encouraged to use this [eclipse projects bash script for subdirectories](https://gist.github.com/1098960). 



###### Catkin-y approach



If you are using catkin, you do not have the possibility to use `make eclipse-project`. You need to execute: 

```
catkin_make --force-cmake -G"Eclipse CDT4 - Unix Makefiles"
```



to generate the `.project` file and then run: 

```
awk -f $(rospack find mk)/eclipse.awk build/.project > build/.project_with_env && mv build/.project_with_env build/.project
```



to pass the current shell environment into the make process in Eclipse. 

After executing this command you will find the project files in the **build/** folder. Now you can import your project as existing project into workspace. 

Maybe you will need to execute the following if you would like to debug your program. To execute this command cd to the **build/** folder. You should do so if you e.g. get an error like "No source available for main()". 

```
cmake ../src -DCMAKE_BUILD_TYPE=Debug
```



For information on the proper approach using catkin, start [here](http://answers.ros.org/question/52013/catkin-and-eclipse/) 



####### Catkin and Python



For me, the above procedure didn't generate a `.pydevproject` file, like `make eclipse-project` ever did. Clicking *Set as PyDev Project* would create a config but without any Paths, so coding would be a hassle. 

***Workaround**:* From within the package you want to program run: 

```
python $(rospack find mk)/make_pydev_project.py
```



Now copy the created file `.pydevproject` (which has all dependency package paths included) to `/build` and import your catkin-project into eclipse or *Set it as PyDev Project* if already imported. 



###### catkin tools



With the new [catkin_tools](http://catkin-tools.readthedocs.org/en/latest/index.html), there are few changed from the Catkin-y method described above. To generate eclipse-project you need to execute: 

```
catkin build  --force-cmake -G"Eclipse CDT4 - Unix Makefiles"
```



to generate the .project files for each package and then run: the following script 

```
ROOT=$PWD
cd build
for PROJECT in `find $PWD -name .project`; do
    DIR=`dirname $PROJECT`
    echo $DIR
    cd $DIR
    awk -f $(rospack find mk)/eclipse.awk .project > .project_with_env && mv .project_with_env .project
done
cd $ROOT
```



To debug use the following command and you can mention the name of the  package to configure that specific project for debug instead of the  entire workspace. Remember to run the script to modify .project to pass  the current shell environment into the make process in Eclipse. 

```
catkin build  --force-cmake -G"Eclipse CDT4 - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
```





##### Importing the project into Eclipse



Now start Eclipse, select **File** --> **Import** --> **Existing projects into workspace**, hit next, then browse for your package's directory (**select root directory**). Do NOT select **Copy projects into workspace**. Then finish. 

You should now be able to browse through the code (hold down **CTRL** while clicking on a function/class name), get auto completion (automatically appears, or press **CTRL-SPACE**) et cetera. 



###### Fixing unresolved includes



There are  many possible reasons why indexing cannot resolve all includes,  functions, methods, variables, etc. Often, fixing the resolving of  includes solves these errors. If you have any problems, these might be  fixed by: 

- If the  dependencies of your project have changed since first adding them to  Eclipse, regenerate the project files and reimport the project into your workspace. 
- Making sure to load your .bashrc environment with Eclipse, by launching it using *`bash -i -c "eclipse"`* (see [Reusing your shell's environment](http://wiki.ros.org/IDEs#Reusing_your_shell.27s_environment)). 
- In Eclipse, right click the project, click properties -> C/C++ general  -> Preprocessor Include Paths, Macros etc. Click the tab "Providers"  and check the box next to "CDT GCC Built-in Compiler Settings [ Shared  ]". 
- Afterwards, right click the project, select Index -> Rebuild. This will rebuild  your index. Once this is done, usually all includes will resolve. 
- As a last resort, you can also manually add folders that will be searched  for headers, using right click project -> properties -> C/C++  Include Paths and Symbols. This is usually not necessary though. 



##### Building the project inside Eclipse



The `eclipse-project` make target automatically tries to set the environment variables  correctly such that building within Eclipse should work out-of-the-box.  Especially if you follow *Reusing your shell's environment* from above. 

If not, this is where you need to start looking: Right click on the project, select **Properties** --> **C/C++ Make Project** --> Environment, and check whether the following environment variables are assigned to the correct values: 

- ROS_ROOT 
- ROS_PACKAGE_PATH 
- PYTHONPATH 
- PATH 

The easiest way to obtain the correct values for your installation is to open a terminal, and run 

```
echo $ROS_ROOT
echo $ROS_PACKAGE_PATH
echo $PYTHONPATH
echo $PATH
```



You should now be able to compile your package properly, for example by hitting **CTRL-B** (or selecting **Project** --> **Build project** in the menu). 

**Note**: When working with multiple projects, Eclipse won't be able to determine the correct build order or when dependent projects have to be rebuilt.  You have to set the project interdependencies manually for each project  in your workspace (see http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.cdt.doc.user/reference/cdt_u_prop_general_pns_ref.htm). 



##### Running and debugging your executables within Eclipse



As for  building within Eclipse, the crucial step here is to set the required  environment variables correctly in the launch configuration. As the same for building, this should work out-of-the-box, especially if you follow *Reusing your shell's environment* from above. 

Create a new launch configuration, right click on the project, select **Run** --> **Run configurations...** --> **C/C++ Application** (double click or click on **New**). Select the correct binary on the **main** tab (**Search project** should work when your binary was already built). Then in the **environment** tab, add (at least) 

- ROS_ROOT 
- ROS_MASTER_URI 

again with the values of your installation. If you are unsure about them, open a terminal and run 

```
echo $ROS_ROOT
echo $ROS_MASTER_URI
```



Finally, if you cannot save the configuration, remove the **@** character in the name of the new run configuration. 

This should now allow you to run and debug your programs within Eclipse. The output directly goes into the **Console** of Eclipse. Note that the ROS_INFO macros use ANSI escape sequences,  which are not parsed by Eclipse; therefore, the output might look  similar to this one (from [Writing a Publisher/Subscriber (C++)](http://wiki.ros.org/roscpp_tutorials/Tutorials/WritingPublisherSubscriber)): 

```
[0m[ INFO] [1276011369.925053237]: I published [Hello there! This is message [0]][0m
[0m[ INFO] [1276011370.125082573]: I published [Hello there! This is message [1]][0m
[0m[ INFO] [1276011370.325025148]: I published [Hello there! This is message [2]][0m
[0m[ INFO] [1276011370.525034947]: I published [Hello there! This is message [3]][0m
```



You could use an ANSI console plugin (e.g. http://www.mihai-nita.net/eclipse/) to get rid of the "[0m" characters in the output. 

##### More eclipse goodies



- Setup a file template that pre-formats whenever a new source or header file  is created. The template could for example contain the license header,  author name, and include guards (in case of a header file). To setup the templates, choose in the Preferences **C/C++->Code Style->Code Templates**. For example, to add the license header choose **Files->C++ Source File->Default C++ source template** and click on **Edit...**. Paste the license header and click **OK**. From now on, all source files while automatically contain the license header. 
- Enable Doxygen with the project properties clicking on **C/C++ General**, **enabling project specific settings** and selecting Doxygen as **Documentation tool**. This option automatically completes Doxygen style comments highlights them. 
- People that are used to the emacs key bindings can select emacs-style bindings in **Windows->Preferences General->Keys** and selecting the emacs **Scheme**. Also, other useful key bindings (e.g. make project) can easily be added. 
- To also index files that live outside the ROS tree (e.g. the boost include files) you can add them in project properties **C/C++ General->Paths and Symbols**. 
- The generated eclipse project also works great for Python code. Just install the [PyDev](http://pydev.org/) plugin for syntax highlighting and code completion. 



##### Auto Formatting



Eclipse  also has extensive formatting configuration capabilities.  To add the  ROS formatting profile to Eclipse, perform the following steps: 

- Download ROS_Format.xml to some location (versions: [Indigo](http://wiki.ros.org/IDEs?action=AttachFile&do=view&target=ROS_format.xml) [Kepler](http://wiki.ros.org/IDEs?action=AttachFile&do=view&target=ROS_format-kepler.xml)) 
- Start Eclipse 
- Select ***Window***->***Preferences***->***C/C++***->***Code Style*** 
- Click ***Import...*** 
- Select *ROS_format.xml* from the location used in step 1 
- Click ***OK*** 

As you edit a file, Eclipse should use this new profile to format your  code following the ROS conventions.  To reformat an entire file, select ***Edit***->***Format***. 



#### CLion



[CLion](https://www.jetbrains.com/clion/) is a cross-platform C/C++ IDE that natively supports CMake and allows working with Python code. 



##### Plugins



There are currently three actively-developed ROS plugins for CLion: 

- [Hatchery](https://plugins.jetbrains.com/plugin/10290-hatchery) 
- [ROS-Robot Operating System](https://plugins.jetbrains.com/plugin/11420-ros-robot-operating-system) 
- [ROS Support](https://plugins.jetbrains.com/plugin/11235-ros-support) 



##### ROS-Robot Operating System



The following instructions describe how to use the plugin, "ROS-Robot Operating System":  



###### Install the plugin



In order to install this plugin, you have to open the *Settings* (from the *File menu*); then from the left panel select pluging in order to show the plugin  panel in the right side and select the marketplace tab; then search for  ROS-Robot Operating System plugin and install it. 



###### Setup the plugin



After installed it, in the left panel of the Settings window, you have a new voce *ROS config*, inside the *Build, Execution, Deployment*. You can use it to configure the ROS version you have installed in your  computer. The plugin automatically found the versions installed in the  default location /opt/ros so usually the plugin is ready to use. If you have a ROS version installed in a different localion, press the button with the ROS icon in order to add to the plugin. 



###### Using the plugin



In order to create a **new workspace**, the *New Project* menu will show the new option *ROS workspace*. In this case, you will be asked to select a ROS version from those configured in the ROS setting panel. 

In order to **import an existing workspace**, you have to use the menu *Import ROS workspace*, selecting the workspace folder. In this case, the plugin will search  from the configured ROS versions and it will setup the project in order  to resolve the ROS dependency. 



###### Running and debugging nodes



CLion  automatically creates Run/Debug configurations for each CMake target in  the project. For automatically created configurations, CLion takes the  target and executable names (in case it is an executable) directly from  the *CMakeLists.txt* target's description. To view, change, and create more configurations, use the **Edit Configurations** dialog (accessible from **Run** on the main menu or from the configuration switcher). 

You can build/rebuild the targets altogether or separately with various Build Actions (click **Build** on the main menu). Choose the desired configuration and run or debug it as a regular application (or a unit test) in CLion. Note that you will  probably need to run ***roscore*** in a terminal in advance. 



###### Run a launch file



It is possible run a .launch file, using the run/debug configuration window. In this case, when the launch file will be executed, the plugin will be  setup the environment as you should have after make "source  devel/setup.bash"   



##### Default CLion support



- A more detailed version of this tutorial can be found in CLion [documentation](https://www.jetbrains.com/help/clion/ros-setup-tutorial.html). 



###### Launching CLion



As for other IDEs, you need to either launch CLion from the ROS-sourced shell 

- 

  

  ```
    sh PATH_TO_CLION/bin/clion.sh
  ```

  
or modify the desktop entry located in **~/.local/share/applications** and named ***jetbrains-clion-\*.desktop***. If there is no such file in that location, generate the entry from within CLion: select **Tools | Create Desktop Entry** from the main menu. In the desktop entry file, change the line that starts with *Exec=* to be the following: 

- 

  

  ```
    Exec=bash -i -c "PATH_TO_CLION/bin/clion.sh" %f
  ```

  

  



###### Opening / Importing a project



In CLion, you have two options for opening a ROS project: 

- Click **File | Open** on the main menu and choose the *CMakeLists.txt* file in the **src** directory of the workspace. In case you are using ***catkin_tools***, and there is no top-level *CMakeLists.txt* for the workspace, use the one for a particular package. Choose **‘Open as project’**. 
- Click **File | Import** and select the **src** directory of your workspace or package to import the project from. 

CLion will treat your ROS project as a regular CMake project. 



###### Configuring build paths



By default, CLion places build output in **cmake-build-debug** or **cmake-build-release** directory, which it creates automatically. For ROS development, it  means that you will have two different builds in CLion and the console.  

To have a single build shared by CLion and console, you need to set the  CLion build paths to the catkin workspace directories. Go to **File | Settings(Ctrl+Alt+S) | Build, Execution, Deployment | CMake** and change two fields: 

1. In *Generation path*, set **workspace_folder/build**. 
2. In *CMake options*, add **-DCATKIN_DEVEL_PREFIX:PATH=workspace_folder/devel**. 



###### Running and debugging nodes



CLion  automatically creates Run/Debug configurations for each CMake target in  the project. For automatically created configurations, CLion takes the  target and executable names (in case it is an executable) directly from  the *CMakeLists.txt* target's description. To view, change, and create more configurations, use the **Edit Configurations** dialog (accessible from **Run** on the main menu or from the configuration switcher). 

You can build/rebuild the targets altogether or separately with various Build Actions (click **Build** on the main menu). Choose the desired configuration and run or debug it as a regular application (or a unit test) in CLion. Note that you will  probably need to run ***roscore*** in a terminal in advance. 



###### Working with launch files



Launch  files cannot be executed directly in CLion, yet you can edit them with  XML syntax highlighting and completion, and also attach the CLion  debugger to a running node. 

- *Edit launch files as XML* with code highlighting and navigation: go to **File | Settings (Ctrl+Alt+S) | Editor | File Types** and select **XML** from the list of Recognized File Types, and add **.launch* extension to the list of Registered Patterns. 
- *Attach the debugger to a running node*: run your launch file from the command line and get the name or PID of the desired node. Call **Run | Attach to Process** from the main menu or press **Ctrl+Alt+F5**, and choose the node to connect to. The debugging process will start as usual.  



#### CodeBlocks



Here's how to create a ROS package using CodeBlocks: 

- Create a new project as you normally do in CodeBlocks, either as a console  project or as a wxWidgets project. Write a manifest.xml file that  specifies the ROS dependencies, as you normally do for a ROS package. To get the compiler and the linker flags, use these commands from a  terminal window: 

  ```
    rospack export --lang=cpp --attrib=cflags PackageName
    rospack export --lang=cpp --attrib=lflags PackageName
  ```

  

  You can just copy and paste the results into the Build Options of your project, specifically: 

  

  - In CodeBlocks, right click on the project name, select Build Options,  select the project (rather than the Debug or Release versions that are  selected by default in the popup window), select the tabs for Compiler  Settings, Other Options, and paste the cflags you got from above.  Then  select the linker settings tab, and in Other Linker Options, paste the  linker flags you got from above.  You can also do this with a bash  script:  copy the flags into bash scripts, make them executable, and put the scripts in place of the long lists of flags.  You can use  environment varialbles in the script.  Note that CodeBlocks allows a  "local" definition of environment variables as well. 

  If you are writing a ROS node, create the msg (and perhaps svr) directory and populate it as you normally do using. 

  

  - ``rospack find roscpp``/scripts/genmsg_cpp msg/MessageName.msg 

  Then be sure to go back and add -Imgs/cpp (and perhaps -I srv/cpp) flags to the cflags in Compiler Settings, Other Options. 

  

  I posted in the Attachments an example of code that works in a   CodeBlocks wxWidgets GUI project and runs a ROS node that subscribes,  advertises, services, and publishes data across various busses.  The  files are nodeTemplate.cpp and nodeTemplate.h 

Here's how to use the sample code: . Create a package called  wxWidgetsNodeTemplate, using the attached manifest.xml file.  Also  create a msg directory and a srv directory. 

- Use the attached RosNodeTemplate.msg file and auto-generate the header for it with 
- ``rospack find roscpp``/scripts/genmsg_cpp msg/RosNodeTemplate.msg 
- Similarly use the attached NodeTemplateServer,srv file and auto-generate the header for it with 
- ``rospack find roscpp``/scripts/gensrv_cpp srv/NodeTemplateServer.srv 
- Now create a CodeBlocks project as detailed above.  Add the attached files, nodeTempalte.h and nodeTemplate.cpp to the project. 
- Now make an instance of nodeTemplate, passing it a pointer to a  wxTextCtrl: 
- m_pNodeTemplate = new nodeTemplate(txtGeneral); 
- It will listen to monitor_node_bus and write to the textbox when it sees activity on that bus. 
- It will service calls to node_service_bus and write to the textbox when the service is called. 
- You can publish on node_bus_out with 
- m_pNodeTemplate->Publish(); 
- . 



#### Emacs



Support through the [rosemacs](http://wiki.ros.org/rosemacs) package. Navigate and tab complete the ros package file system, live  tracking and tab completion of topics, tracking and notifications when  nodes startup/die, etc. 

For [helm](https://emacs-helm.github.io/helm/) integration a package called [helm-ros](https://github.com/davidlandry93/helm-ros) is available. It's integration with helm makes it easy to find files in a fuzzy way. It is available through [melpa](http://melpa.org). 



#### Vim



The most feature-rich Vim plugin for ROS development is [vim-ros](https://github.com/taketwo/vim-ros). It provides `:Roscd`, `:Rosed`, and `:TabRosed` commands with <Tab> completion, manages your `&makeprg` setting (to allow building with `:make`), brings syntax highlighting and omni-completion for ROS filetypes (e.g.  message descriptions, launch files), facilitates integration with `Ultisnips` and `Syntastic` plugins, and whatnot. The plugin is written in Python and, as such, is contribution-friendly. 

Alternative support is through the [rosvim plugin](http://wiki.ros.org/IDEs?action=AttachFile&do=view&target=rosvim.vim), from Michael Styer. Drop the file in `~/.vim/plugin`. 

Extended version of rosvim.vim is [here](https://github.com/ompugao/ros.vim) (sorted and implemented <Tab> completion feature), and [ctrlp.vim](https://github.com/kien/ctrlp.vim) interface of ros.vim is [here](https://github.com/ompugao/ctrlp-ros). You can install these plugins easily by using vimscript installation plugins such as https://github.com/gmarik/vundle and https://github.com/Shougo/neobundle.vim. 

A useful complement to these plugins is the YouCompleteMe plugin for code completion. Thanks to a configuration file from Gaël Ecorchard ([.ycm_extra_conf.py](https://gist.github.com/galou/92a2d05dd772778f86f2)), the include paths are automatically added to the YouCompleteMe configuration for ROS packages. 



#### NetBeans



The  NetBeans IDE is written in Java and supports development in Java and  many other programming languages. Here, C/C++ development support will  be of interest. 



##### Installing NetBeans



Although NetBeans is included in Ubuntu repositories, everything described here was tested with [NetBeans](http://wiki.ros.org/NetBeans) 6.9.1. 

- Go to http://www.netbeans.org/ 

- Click on "Download FREE (NetBeans 6.9.1)" in the middle of the page 

- Download the C/C++ bundle 

  

  - If http://www.netbeans.org/ is experiencing problems, try e.g. http://dlc.sun.com.edgesuite.net/netbeans/6.9.1/final/bundles/netbeans-6.9.1-ml-cpp-linux.sh (MD5 sum from http://www.netbeans.org/ is 26f585185b95682cb07d3e5218760702) 

- Run (as root) the downloaded file (install script and embedded archive) 



```
$ sudo sh netbeans-6.9.1-ml-cpp-linux.sh
```





##### Getting ROS environment variables in NetBeans



NetBeans  can "import" project from existing sources. It can use Makefiles, and  even run configure script or CMake to generate one. But, that kind of  automatic project configuration and build would overwrite stub makefile  that every ROS package has. That makefile in essence runs ROS build  system for a package, and that is what we want NetBeans to do. 

In order to use [rosmake](http://wiki.ros.org/rosmake) from NetBeans, we need to set ROS environment variables in NetBeans.  Since NetBeans is started with a shell script on Linux, we can include  the variables in the script. 



###### In recent ROS (where rosinstall generates setup files for multiple types of shell)



Since from recent versions [rosinstall](http://wiki.ros.org/rosinstall) generates `setup.sh`, `setup.bash` and `setup.zsh` (as oposed to just `setup.sh` which was actually a `bash` script), there is no need for all the steps that are described in the next section. 

The following will suffice to get ROS environment variables to NetBeans: 

```
$ roscd
$ cd ..
$ echo ". $(pwd)/setup.sh" > ~/.netbeans/6.9/etc/netbeans.conf
```



We don't actually need perks specific to `bash`. 

The exact path of **netbeans.conf** for the various OS can be found here: http://wiki.netbeans.org/FaqNetbeansConf 



###### In previous ROS



If [rosinstall](http://wiki.ros.org/rosinstall) doesn't generate setup files for multiple types of shell, you need to do the following. Since ROS shell tools are for bash, we'll convert NetBeans startup script from `sh` to `bash`. Simply edit the first line of NetBeans startup script (located at `/usr/bin/netbeans` if you installed from the Ubuntu package, or possibly `/usr/local/netbeans-6.9.1/bin/netbeans` if you installed manually) from 

```
#!/bin/sh
```



to 

```
#!/bin/bash
```



Further down the startup script it can be seen that the file `~/.netbeans/6.9/etc/netbeans.conf` is included if it exists. We'll create that file like this 

```
$ roscd
$ cd ..
$ echo "source $(pwd)/setup.sh" > ~/.netbeans/6.9/etc/netbeans.conf
```



Now, it just takes to modify NetBeans .desktop launcher (`/usr/share/applications/netbeans-6.9.1.desktop`). Change the line 

```
Exec=/bin/sh "/usr/local/netbeans-6.9.1/bin/netbeans"
```



to 

```
Exec=/bin/bash "/usr/local/netbeans-6.9.1/bin/netbeans"
```



And that is it. Next time you start NetBeans it will have ROS environment variables, and you'll be able to use e.g. [rosmake](http://wiki.ros.org/rosmake). 



##### Making NetBeans project



We'll try to setup project for Microstrain 3DM-GX2 IMU driver package, so note it's path: 

```
$ roscd microstrain_3dmgx2_imu
$ pwd
```



- Start "C/C++ Project with Existing Sources" wizard 
- Use the above path to "Specify the folder that contains existing sources" 
- Select "Custom" Configuration Mode (note that Automatic Mode recognizes cmake) 
- Proceed with the wizard accepting defaults 

You should get a NetBeans project for [microstrain_3dmgx2_imu](http://wiki.ros.org/microstrain_3dmgx2_imu) package with automatically configured Code Assistance (and almost  working for all dependencies). E.g. you can see that the bullet library  headers weren't parsed. 

We will configure Code Assistance manually. That means entering paths to  all header files the package uses and all preprocessor definitions. 

To get the paths to include files for the package we will use [rospack](http://wiki.ros.org/rospack). Further, we'll use `sed` to format them for easier input to NetBeans. 

```
$ rospack cflags-only-I microstrain_3dmgx2_imu | sed 's/ /:/g' -
```



Open the project properties. Go to Code Assistance -> C++ Compiler and  paste the output of the above command to Include Directories field. 

Use [rospack](http://wiki.ros.org/rospack) to find the preprocessor definitions and enter them manually. 

```
$ rospack cflags-only-other microstrain_3dmgx2_imu
```





##### Code auto formatting in NetBeans



Following file [netbeans-ros-code_style.zip](http://wiki.ros.org/IDEs?action=AttachFile&do=view&target=netbeans-ros-code_style.zip) is prepared to enable auto formatting of C++ code in NetBeans as defined in [CppStyleGuide](http://wiki.ros.org/CppStyleGuide). In order to use it, you should import it to Netbeans (Tools -> Options -> Import). 

With this, example given in [CppStyleGuide#Formatting](http://wiki.ros.org/CppStyleGuide#Formatting) will be identically formated, except of extra blank lines before  function or class definitions. For a discussion see Google C++ style  guide [Vertical Whitespace](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Vertical_Whitespace#Vertical_Whitespace). 



#### QtCreator



As QtCreator supports opening CMake projects out of the box, it does not require a setup procedure ***if started from a terminal***.  Note that this is absolutely crucial, because otherwise the  environment will not be set correctly and functionality related to  rosbuild or catkin will fail when running cmake. 

Note that instead of starting QtCreator from a terminal, you can use the  following modification to the desktop file which normally in Ubuntu  resides in `/usr/share/applications` if you did a system wide installation or in `~/.local/share/applications` if you installed it only for your user: 

```
$ cat qtcreator.desktop
[Desktop Entry]
Exec=bash -i -c qtcreator %F
Icon=qtcreator
Type=Application
Terminal=false
Name=Qt Creator
GenericName=Integrated Development Environment
MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.nokia.qt.qmakeprofile;application/vnd.nokia.xml.qt.resource;
Categories=Qt;Development;IDE;
InitialPreference=9
```



In Ubuntu 13.04 and later, the third line must read: 

```
Icon=QtProject-qtcreator
```



You should not try to generate this file yourself, but rather modify the  file that was created when you installed QtCreator.  Add `bash -i -c` in the `Exec` line and use it in your launcher. This will run your QtCreator in a shell which should `source` all required `setup.bash` files of your ros installation and workspace.  More about desktop files and their locations for Ubuntu can be found [here](https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles). Note also that the same trick can be used with eclipse. 

If you are experiencing issues with the qtcreator package shipped by  Ubuntu (or want to use a more up to date version of QtCreator) when  opening the CMakeLists, then try installing QtCreator from [Nokia's installer](https://www.qt.io/download-open-source/#section-9). 



##### rosbuild



To open a rosbuild ROS package code as a project, use "Open File or  Project" and select the CMakeLists.txt of your ROS package. Take care to select the "[package_name]/build" directory as the build directory,  which is the ROS default. On the next screen click 'Run Cmake' and then  Finish. This may not show all  the folders such as launch and include in the project tree. If you want  to choose the files manually, goto File->New File or  Project->Import Project->Import Existing Project and selected to  choose all files/folders included in the project. 



##### catkin_make



To open a catkin code as a project, use "Open File or Project" and select  the top level CMakeLists.txt of the catkin workspace (e.g.  "catkin_ws/src/CMakeLists.txt"). Select the catkin build folder (e.g.  "catkin_ws/build") as the build directory and 'Run CMake' (in order to  enable debugging add following line into arguments edit box:  -DCMAKE_BUILD_TYPE=Debug). 

Recently this has started to fail with errors like "CMake Error: The source  directory "/opt/ros/lunar/share/catkin/cmake" does not appear to contain CMakeLists.txt.", because the main CMakeLists is a symlink to a  non-writable location. The workaround is to make a copy of  toplevel.cmake instead of using a symlink: 

```
mv CMakeLists.txt CMakeLists.txt.old
cp /opt/ros/lunar/share/catkin/cmake/toplevel.cmake CMakeLists.txt
```



To be able to modify all the files in the workspace add those lines in "src/CMakeLists.txt" : 

```
#Add custom (non compiling) targets so launch scripts and python files show up in QT Creator's project view.
file(GLOB_RECURSE EXTRA_FILES */*)
add_custom_target(${PROJECT_NAME}_OTHER_FILES ALL WORKING_DIRECTORY ${PROJECT_SOURCE_DIR} SOURCES ${EXTRA_FILES})
```



If you want the project to be named something else than "Project" then add a line at the top with `project(!MyProjectName)`. 

You may specify the correct catkin *devel* and *install* spaces at Projects->Build Settings by providing the following CMake arguments: `-DCATKIN_DEVEL_PREFIX=../devel -DCMAKE_INSTALL_PREFIX=../install` 



##### catkin tools



With the new [catkin_tools](http://catkin-tools.readthedocs.org/en/latest/index.html), there is no longer a top level make file for the whole workspace.  Instead, open each package as an individual project in QtCreator.  Make  sure, that the build folder is set to `ws/build/your_package` instead of `ws/build`. 

***Before opening a package with QtCreator, though, make sure to build the package once with `catkin build`.***  If your build artifacts (binaries, libraries, ...) end up in the wrong directory, you built the package first with QtCreator.  You can check,  whether you have this problem by simple doing a `rosrun` of your package's node, change code, recompile with QtCreator and do a `rosrun` again -- if you don't see your changes in the executable's behavior, it is probably installed into the wrong directory.  To *resolve* this issue, just clean the package (`catkin clean ` for linked layout, for newer catkins, remove the `build/` folder) and rebuild it with `catkin build`. 

With QtCreator of version 4 and higher, you can (and actually have to) configure your compiler etc. in a *Kit*.  Go to *Tools* -- *Options* -- *Build & Run* -- *Kits*.  In the *Default* kit (or create a new kit for ros) 

- select the compiler you want to use in catkin 
- select *[CodeBlocks](http://wiki.ros.org/CodeBlocks) -- Unix Makfiles* 
- change the *CMake Configuration* to only contain `QT_QMAKE_EXECUTABLE:STRING=%{Qt:qmakeExecutable}` (i.e. remove the define for `CMAKE_CXX_COMPILER`) 

In your workspace, execute 

```
catkin config --cmake-args -DCMAKE_CXX_COMPILER:STRING=/usr/bin/g++ --
```



where you substitute `/usr/bin/g++` with the compiler you actually want to use (and which is the same that you selected in the kit above). See [this discussion](https://github.com/catkin/catkin_tools/issues/369) about this issue. 

You can configure some *default paths* in QtCreator: 

- The default build path (what you normally have to set manually once you open a new project): In *Tools* -- *Options* -- *Build & Run* -- *General* set the *Default build directory* to 



```
%{Env:CURRENT_CMAKE_BUILD_DIR}/%{CurrentProject:Name}
```



- and in your `~/.bashrc` (or ~/.zshrc`) add a line similar to 



```
export CURRENT_CMAKE_BUILD_DIR="$(catkin locate --workspace ~/workspace --build)"
```



- to define the variable `CURRENT_CMAKE_BUILD_DIR`. 
- The path in which to look for projects (i.e. where to start the search when you want to open a new project): *Tools* -- *Options* -- *Build & Run* -- *General* -- *Projects directory* set *Directory* to `/home//workspace/src` (or wherever your workspace is). 



##### Enable Clang Code Model



Install recent clang (version >= 3.6) and [this plugin](http://doc.qt.io/qtcreator/creator-clang-codemodel.html).  See the link for how to enable it.  Although this may slow down your  computer it is a very valuable tool to give you compiler warnings  on-line. 



##### Troubleshooting



When running `cmake` in QtCreator (when you open the package), check the output for error messages -- they provide a clue on what is going wrong. 

To remove cached/stored information for a project, remove the `CMakeLists.txt.user` (possibly with some trailing numbers) in your project and re-open the  project.  If that does not solve your problem, repeat (remove `CMakeLists.txt.user`) and additionally remove (or rather rename) the QtCreator configuration in `~/.config/QtProject` and `~/.local/share/data/QtProject/qtcreator` and try again. 



#### Qt Creator Plugin for ROS



Please refer to instructions [here](https://github.com/ros-industrial/ros_qtc_plugin/wiki). 



#### PyCharm (community edition)



PyCharm is  an IDE for Python. In order to run and debug ROS functionality you need  to modify the desktop file for PyCharm (the same procedure as for other  IDE's). In Ubuntu 16.04 (and possibly earlier versions), you can edit  the launcher file in either `/usr/share/applications` or `~/.local/share/applications` (depending on whether or not you installed [PyCharm](http://wiki.ros.org/PyCharm) for all users). The launcher file may be called `pycharm-community.desktop` or `jetbrains-pycharm-ce.desktop`. Change the line that reads 



```
Exec="/usr/lib/pycharm-community/bin/pycharm.sh" %f
```



by adding *`bash -i -c `* at the beginning: 

```
Exec=bash -i -c "/usr/lib/pycharm-community/bin/pycharm.sh" %f
```





##### Plugins



There are currently two actively-developed ROS plugins for [PyCharm](http://wiki.ros.org/PyCharm): 

- [Hatchery](https://plugins.jetbrains.com/plugin/10290-hatchery) 
- [ROS Support](https://plugins.jetbrains.com/plugin/11235-ros-support) 



##### packages



In order to work with packages just create new project in parent folder  for all your packages or in particular package. Please note that folder  .idea with project files will be created. You can add it to .gitignore  file in case if you are using Git and do not want to commit this file to repository. PyCharm will  parse all files in the packages and allow you quick navigation, fast  code completions, run and debug Python code, unitest run and debug. 



##### code





###### run



Code can be run using roslaunch or rosrun command from command line. Simple Python files can be run using run context menu. 



###### debug



In order to debug Python node do the following changes 

- Comment node in the launch file my_nodes.launch 
- If node has any parameters specified inside put them into <group> tag with ns attribute equal to node name 
- Launch my_nodes.launch using roslaunch command 
- Run Python node from PyCharm IDE in debug mode 



##### unittest





###### run



Unittest can be simple run using content menu on the file in the project tree or on particular method in the code. Results would be shown in UI. 



###### debug



Unittest can be normally debug using start debug menu. 

In case of integration test (rostest) 

- Comment <test> tag in the my_file.test launch file 
- launch my_file.test using roslaunch not rostest 
- launch test using PyCharm unittest debug from IDE 



##### Custom Messages/Services



Define and build your messages/services as usual. In order Pycharm to recognize them (for autocompletion, etc.): 

- Open **File** - **Settings** 
- Select **Project: projectname** - **Project Structure** 
- Select **src** folder and click on **Mark as: Sources** 
- Click **OK** 



#### KDevelop



KDevelop has excellent C++ support, GDB integration and does semantic syntax  highlighting with individual colors for different variables. Such as [QtCreator](http://wiki.ros.org/IDEs#QtCreator), KDevelop supports opening CMake projects out of the box. 

KDevelop must know the ROS environment variables, therefore start KDevelop from a terminal that has sourced your catkin workspace already. Alternatively, create the following desktop file according to the remarks in the [general section](http://wiki.ros.org/IDEs#Reusing_your_shell.27s_environment) and mark it as executable: 

```
mkdir -p $HOME/.local/share/applications/
touch $HOME/.local/share/applications/KDevelop.desktop
####### Now edit the file using the editor of your choice and insert the text from the box below
chmod +x $HOME/.local/share/applications/KDevelop.desktop
```





```
[Desktop Entry]
Type=Application
Terminal=false
Exec=bash -i -c "kdevelop"
Name=KDevelop
Icon=kdevelop
```





##### Building catkin packages



In order to build your packages in your catkin workspace, you can choose  between two different approaches. The particular choice depends on your  utilized build system and your personal preference, whether to build the complete catkin workspace at once or to build each package separately with KDevelop. 



###### Import catkin top-level workspace



The following steps describe how to import the complete catkin workspace into KDevelop. This approach relies on the default catkin build system in ROS. 

- It is recommended to clear the catkin build folder before importing the  project. You can safely remove the build folder from your catkin  workspace since it will be created again during the cmake configure and  build process. 

- Start KDevelop from shell or using the modified desktop shortcut mentioned above. 

- Goto the "Project" tab and select "Open / Import Project...". Switch to your catkin source space (we assume `~/catkin_ws/src` here) and select "CMakeLists.txt". Afterwards, you may replace the  "Name" by your workspace name (default: "src"). Make sure that the  selected "Build System" is "CMake Project Manager". Proceed by clicking  on "Finish". 

- A new window should appear that contains cmake build configurations. 

- Set the "Build Directory" to the catkin build space, e.g.: `/home/user/catkin_ws/build/` 

- Select your desired "Build type". 

- Finally, add the following **Extra Arguments** to make sure, that the binaries and libraries are moved into the correct catkin spaces (devel and install): 

  `-DCATKIN_DEVEL_PREFIX=../devel -DCMAKE_INSTALL_PREFIX=../install` 

- Wait until KDevelop has finished importing your workspace. Try to compile your code by clicking on the "Build button". 

- After switching to the source code of an underlying package let KDevelop some seconds to parse for auto-completion and code highlighting. 



###### Build individual packages with catkin_tools



This approach uses the custom [catkin_tools](http://catkin-tools.readthedocs.io/en/latest/index.html) environment for building your packages. Make sure to configure your catkin-tools workspace properly before you proceed with the KDevelop setup. 

Perform the steps as mentioned in the section before, but with the following differences: 

- Select the "package/CMakeLists.txt" rather than any top-level "CMakeLists.txt". 

- Set the "Build Directory" to a subfolder in your build space according to the **package name**, e.g.: `/home/user/catkin_ws/build/package` 

- **Extra Arguments** must be adapted to match the proper workspace structure: 

  `-DCATKIN_DEVEL_PREFIX=../../devel -DCMAKE_INSTALL_PREFIX=../../install` 

  *Note, for nested subdirectory structures an appropriate amount of ../ must be added.* 



##### Running and debugging your executables



Configure executable: 

- After the catkin workspace is successfully imported and **builded**, goto: "Run -> Configure Launches...". 
- Click on the "Add New..." menu and try to find your executable in the  "Project Executables" submenu. If the binary is not listed there, you  can add it manually using "Add New... -> Compiled Binary" (specify  the location of the executable/binary, e.g.  "~/catkin_ws/devel/lib/package/node_name"). 
- Optionally specify any arguments. 
- Finish configuration by clicking "OK". 

Run executable: 

- Just click on "Execute". In case of multiple configured executables, select  the current executable at "Run -> Current Launch Configuration". 

Debug executable: 

- Add a breakpoint to a related package source file and click on the "Debug"  button. Make sure that the current launch configuration is set to the  correct binary. 



##### Remarks



If something went wrong, delete the "*.kdev4" file and the ".kdev4" folder inside your source space and try to repeat the procedure. 

The "Build Type" selected during project import (e.g. "Debug", "Release", "[RelWithDebInfo](http://wiki.ros.org/RelWithDebInfo)") can be changed by right-clicking on the project -> "Open  Configuration...". Select CMake in the left menu and change the CMake  variable "CMAKE_BUILD_TYPE" appropriately. 

**Note**, if a package inside the catkin workspace specifies its own "Build Type", e.g. by adding `set(CMAKE_BUILD_TYPE Release)` to the underlying package "CMakeLists.txt", it will be used for that  package instead of the global one defined in the top-level CMake  project. 

KDevelop displays a lot of files and (ros) binaries in the source tree that are  not really interesting for the developer and finding individual files  could be really confusing. Right click on the project panel tab on the  left side and un-tick "Show Targets" 

![KDevelop - Show targets](http://wiki.ros.org/IDEs?action=AttachFile&do=get&target=kdevelop+show+targets.png) 



#### RoboWare Studio



RoboWare Studio is an IDE based on [VSCode](http://code.visualstudio.com) and is specially designed for ROS (indigo/jade/kinetic). With a  double-click installation, RoboWare Studio can automatically detect and  load ROS environment without additional configuration. The  “out-of-the-box” feature helps developers pick it up and figure it out  quickly. It provides an intuitive graphical interface for developers to  create ROS workspace/package, add source files, create  messages/services/actions, list generated packages/nodes, etc.  Meanwhile, The CMakeLists.txt file can be updated automatically. It supports release-build and debug-build. Developers can debug C++ and  Python codes right from the editor, with break points, call stacks, and  an interactive console. It also displays ROS packages and nodes in the  interface. 

RoboWare Studio is open sourced on Github: https://github.com/tonyrobotics/roboware-studio. 



##### Installation



Go to http://www.roboware.me/, download the latest version of RoboWare Studio and install it easily by double click the deb file or by the following commands in a terminal: 

```
$ cd /path/to/deb/file/
$ sudo dpkg -i roboware-studio_[version]_[architecture].deb
```



After installation, RoboWare Studio automatically detect and load ROS environment without additional configuration. 



##### Uninstallation



Use the following commands to uninstall RoboWare Studio: 

```
$ sudo apt-get remove roboware-studio
```





##### Launch



Click the Ubuntu logo in the upper-left corner of the screen to activate Dash, search for “roboware-studio” and launch. You can also start the application from terminal by executing: 

```
$ roboware-studio
```



For more details of software features and usage please refer to http://www.roboware.me/. 



#### Visual Studio Code (VSCode)



There is an open-source [VSCode extension](https://marketplace.visualstudio.com/items?itemName=ms-iot.vscode-ros) available for ROS development which you can install using the command `ext install ros`. The extension does not require additional configuration and will enable ROS functionality when a folder in a catkin workspace is opened. See  the [README](https://github.com/ms-iot/vscode-ros/blob/master/README.md) for more details about the extension. 



#### RDS: ROS Development Studio



[ROS Development Studio (RDS)](http://www.theconstructsim.com/rds-ros-development-studio/) is an online IDE which allows you program and test any robot using only a web browser. 

With RDS, you will be able to: 

- Develop ROS programs for robots in a faster way, with an already setup IDE environment that includes autocomplete. 
- Test the programs in real time on the provided simulated robots. Use the  provided simulations or upload your own. Quickly see the results of your programming. 
- Debug using graphical ROS tools. 
- Test what you have developed on RDS in the real robot (if you have it all of these are using ONLY a web browser without any installation and not  limited by any operating system. DEVELOP FOR ROS USING WINDOWS, LINUX OR OSX. 